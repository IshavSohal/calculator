let operands = []; // represents the operand(s) currently on the screen
let operator = " "; // represents the current operators of the operation displayed
let resultState = true; // set to true when the display (exclusively) contains output generated by the calculator
let errorState = false; // set to true when an erroneous calculation is attempted

let digitButtons = document.querySelectorAll(".number");
let operatorButtons = document.querySelectorAll("#buttons #controls button");
let display = document.querySelector("#display > input");
let clearButton = document.querySelector("#clear");
let equalButton = document.querySelector("#equal");
let backspaceButton = document.querySelector("#backspace");
let decimalButton = document.querySelector("#decimal");
let signChangeButton = document.querySelector("#signChange");

const add = (x, y) => x + y;
const subtract = (x, y) => x - y;
const multiply = (x, y) => x * y;
const divide = (x, y) => x / y;

const operate = (x, y, operator) => {
    if (y === undefined) {
        return +x;
    }
    switch (operator) {
        case "+":
            return add(+x, +y);
        case "-":
            return subtract(+x, +y);
        case "x":
            return multiply(+x, +y);
        case "/":
            if (+y !== 0) {
                return divide(+x, +y);
            }
        case " ":
            if (x && y === "") {
                return +x;
            }
    }
};

digitButtons.forEach((button) => {
    button.addEventListener("click", () => {
        // if ERROR or the result of an operation is on the screen, entering a digit should clear the display
        // before adding that number to the screen
        if (errorState || resultState) {
            display.value = "";
            resultState = false;
            errorState = false;
        }
        display.value += button.innerText;
    });
});

signChangeButton.addEventListener("click", () => {
    if (!errorState && +latestOperand() !== 0) {
        const operatorList = display.value.split(operator);
        const operandsExceptLast = operands.join("").trim();
        if (operator === "-") {
            display.value = operandsExceptLast + "+" + latestOperand();
            operator = "+";
        }

        // look at the latest operand. if it is not prefixed by a -, then prefix it with -. If it is, then
        // remove the -. Here the - should not count as an operator
        else if (latestOperand().at(0) === "-") {
            display.value = operandsExceptLast + (operator === " " ? "" : operator) + latestOperand().slice(1);
        } else {
            display.value = operandsExceptLast + (operator === " " ? "" : operator) + "-" + latestOperand();
        }
        resultState = false;
    }
});

decimalButton.addEventListener("click", () => {
    // should only be applied when the current operand does not already contain a decimal
    if (!errorState && !latestOperand().includes(".")) {
        const operandsExceptLast = operands.join("").trim();
        const lastOperand = (latestOperand() === "" ? "0" : latestOperand()) + ".";
        display.value = operandsExceptLast + (operator === " " ? "" : operator) + lastOperand;
        resultState = false;
    }
});

operatorButtons.forEach((button) => {
    if (!["clear", "equal", "backspace"].includes(button.id)) {
        button.addEventListener("click", () => {
            // if ERROR is on screen, user should not be allowed to enter an operator
            // if the result of an operation is on the screen, user should be allowed to follow
            // it with an operator
            if (!errorState) {
                // If an operator is being replaced, then there is no operation to evaluate.
                // An operator is being replaced when the last operand is empty, and the most recent
                // entry into the display is an operator
                if (latestOperand() !== "") {
                    evalOperation();
                    operands = [display.value];
                } else {
                    if (operator !== " ") {
                        display.value = operands.join("");
                    }
                }
                display.value += button.innerText;
                operator = button.innerText;
                resultState = false;
            }
        });
    }
});

clearButton.addEventListener("click", () => {
    display.value = "0";
    operands = [];
    operator = " ";
    resultState = true;
});

const latestOperand = () => display.value.split(operator).at(-1);

const evalOperation = () => {
    if (!errorState) {
        operands.push(latestOperand());
        const validOperands = operands.reduce(
            (allNumeric, current) => allNumeric && !isNaN(current) && !isNaN(parseFloat(current)),
            true
        );

        if (validOperands) {
            const operationRes = operate(operands[0], operands[1], operator);
            if (operationRes === undefined) {
                return false;
            }
            display.value = Math.round(operationRes * 100000) / 100000;
            operator = " ";
            operands = [];
            resultState = true;
            return true;
        }
        return false;
    }
    return false;
};

equalButton.addEventListener("click", () => {
    if (!evalOperation()) {
        display.value = "ERROR";
        operands = [];
        operator = " ";
        errorState = true;
    }
});

backspaceButton.addEventListener("click", () => {
    if (!(errorState || resultState)) {
        // Check if the current operator was erased, and if so update the operator variable
        // Also, clear the operands array, so that when evalOperation() is called again, it has
        // an operands array that is not dependant on what the (now deleted) operand detected as the
        // operand that preceded it
        if (latestOperand() === "") {
            operator = " ";
            operands = [];
        }

        display.value = display.value.substr(0, display.value.length - 1);
        if (display.value === "") {
            display.value = "0";
            resultState = true;
        }
    }
});
